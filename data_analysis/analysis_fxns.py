import pandas as pd
import numpy as np

"""
PREPROCESSING
"""

def getStateMachineMapping(session):
    state_machine_mapping = {}
    state_names = []
    event_names = []

    settings_df = session['settings']
    
    for column in settings_df:
        if pd.notna(settings_df[column].iloc[0]):
            state_machine_mapping[settings_df[column].iloc[0]] = column
            state_names.append(column)
        elif pd.notna(settings_df[column].iloc[1]):
            state_machine_mapping[settings_df[column].iloc[1]] = column
            event_names.append(column)
    
    session["events"]['Event'] = pd.to_numeric(session["events"]['Event'], errors='coerce')
    session["events"]['Event'] = session["events"]['Event'].map(state_machine_mapping)

    return session, state_machine_mapping, state_names, event_names

def GroupTrialsbyTime(session, time_bin=60000):
    times = session["summary"]['time']
    times = pd.to_numeric(times, errors='coerce')
    max_time = times.max()
    bins = range(0, max_time + time_bin + 1, time_bin)
    bin_indices = np.digitize(times, bins)
    bin_counts = pd.Series(bin_indices).value_counts().sort_index()
    bin_counts.index = [f"{bins[i-1]}-{bins[i]} ms" for i in bin_counts.index]
    return bins, bin_counts

def RemoveDuplicateEvents(mapped_df):
    lick_events = ["left_lick", "center_lick", "right_lick"]
    events_df = mapped_df[mapped_df['Event'].isin(lick_events)]
    duplicated_times = events_df['Timestamp'].duplicated(keep=False)
    duplicates_df = events_df[duplicated_times]
    mapped_df_filtered = mapped_df.drop(duplicates_df.index)
    return mapped_df_filtered, duplicates_df

def getMotivatedTrials(session, time_bin=60000, threshold=0.5):

    """
    Note: this function should account for if cutoff_time is in the middle of the ITI, during the reward delivery, the start of a trial 
    --> While this function would still include that trial in 'summary', we want to include all of the events in that trial
    --> Can be solved if we have a function that can get all events in a trial --> then just get all events in every trial before the cutoff itme
    """

    bins, bin_counts = GroupTrialsbyTime(session, time_bin)
    
    min_num_trials = threshold*max(bin_counts)
    cutoff_time = bins[-1]
    for i, count in enumerate(bin_counts):
        if count < min_num_trials:
            cutoff_time = bins[i]
            break
    
    if cutoff_time != bins[-1]:
        session['summary']['time'] = pd.to_numeric(session['summary']['time'], errors='coerce')
        session['events']['Timestamp'] = pd.to_numeric(session['events']['Timestamp'], errors='coerce')
        
        session['summary'] = session['summary'][session['summary']['time'] <= cutoff_time]

        last_trial_time = session['summary']['time'].max() + 4050
        session['events'] = session['events'][session['events']['Timestamp'] <= last_trial_time]

    return session

def getPreprocessedSessionData(session):

    """
    This function does some small "preprocessing" steps, mainly:
    1. removing duplicate "lick" events, likely caused by electrical noise in the setup.
    2. removing trials and events that occur after the mouse has become disengaged with the task 
    """

    # First, it removes duplicated events
    session, mapping, state_names, event_names = getStateMachineMapping(session)
    session["events"], duplicates_df = RemoveDuplicateEvents(session["events"])

    # Second, it removes any trials and events after the mouse becomes disengaged with the task
    session = getMotivatedTrials(session)

    return session

"""
SESSION STATISTICS
"""

def getStateandEventNames(session):
    state_names = []
    event_names = []
    settings_df = session['settings']
    for column in settings_df:
        if pd.notna(settings_df[column].iloc[0]):
            state_names.append(column)
        elif pd.notna(settings_df[column].iloc[1]):
            event_names.append(column)
    return state_names, event_names

def getNumTrials(session):
    return session["summary"]['n_trials'].iloc[-1]

def getNumRewards(session):
    num_rewards = session["summary"]['n_rewards'].iloc[-1]
    total_reward_amount = session["summary"]['total_reward_amount'].iloc[-1]
    if total_reward_amount == 0 and session["date"] == '2024-03-27':
        total_reward_amount = 7.5*num_rewards
    return num_rewards, total_reward_amount

def getNumStateChanges(session):
    return session["summary"]['n_state_changes'].iloc[-1]

def getActionsandRewards(session):
    choice_data = session["summary"]['choice']
    rewards_data = session["summary"]['outcome']
    mapped_choice_data = choice_data.map(session["choice mapping"])
    return np.array(mapped_choice_data), np.array(rewards_data.astype(int))

def getCurrentState(session):

    def max_value(list):
        return np.argmax(list)
    
    state_data = np.array(session["summary"]['current_state'])
    reward_probabilities_data = session["summary"]['current_reward_probabilities']
    high_arm_data = session["summary"]['high_arm'].map(session["choice mapping"]).to_numpy()

    return state_data, high_arm_data

def getStateChanges(session):
    session["summary"]['state_change'] = session["summary"]['n_state_changes'].diff().fillna(0) > 0
    state_changes = session["summary"][session["summary"]['state_change']][['time', 'n_trials']]
    return state_changes

def GroupTrialsbyState(session):
    trial_groups = []
    begin_range = 0
    state_data, high_arm_data = getCurrentState(session)
    state_changes = getStateChanges(session)

    for i in range(len(state_changes) + 1):
        if i == len(state_changes):
            end_range = getNumTrials(session)
        else:
            end_range = state_changes.iloc[i]['n_trials'] - 1
        indices = np.arange(begin_range, end_range)
        trial_group = {
            "indices": indices,
            "trials": indices + 1,
            "length": indices.shape[0],
            "state": state_data[begin_range],
            "high_arm": high_arm_data[begin_range]
        }
        begin_range = end_range
        trial_groups.append(trial_group)

    return trial_groups

def getITIEvents(session):

    state_names, event_names = getStateandEventNames(session)
    session["events"]['Is_State'] = session["events"]['Event'].isin(state_names)
    session["events"]['Is_ITI'] = session["events"]['Event'] == 'inter_trial_interval'
    session["events"]['ITI_Active'] = session["events"]['Is_ITI'].replace(False, None).ffill().fillna(False)

    iti_events = session["events"][(session["events"]['ITI_Active'] == True) & (~session["events"]['Is_State'])]
    return iti_events

def getITIEventsAcrossTrials(session):

    state_names, event_names = getStateandEventNames(session)
    session["events"]['Is_State'] = session["events"]['Event'].isin(state_names)
    session["events"]['Is_ITI'] = session["events"]['Event'] == 'inter_trial_interval'
    session["events"]['ITI_Active'] = session["events"]['Is_ITI'].replace(False, None).ffill().fillna(False)

    iti_starts = session["events"][session["events"]['Event'] == 'inter_trial_interval']['Timestamp']
    next_state_times = session["events"][session["events"]['Is_State']].shift(-1)['Timestamp']
    iti_ends = next_state_times[iti_starts.index].reset_index(drop=True)

    iti_events_across_trials = []
    for start, end in zip(iti_starts, iti_ends):
        iti_events = session["events"][(session["events"]['Timestamp'] > start) & (session["events"]['Timestamp'] < end) & (~session["events"]['Is_State'])]
        num_events = len(iti_events)
        iti_events_across_trials.append({
            'iti_events': iti_events,
            'num_events': num_events
        })
    
    return iti_events_across_trials

def getTypeofITIEventAcrossTrials(session):
    num_trials = getNumTrials(session)
    choice_mapping = session["choice mapping"]
    actions, rewards = getActionsandRewards(session)
    _, high_arm = getCurrentState(session)

    def map_choice(event):
        choice = event.split('_')[0]
        return choice_mapping.get(choice, -1)

    iti_events_across_trials = getITIEventsAcrossTrials(session)
    for iti_events in iti_events_across_trials:
        iti_events['iti_events']['Choice'] = iti_events['iti_events']['Event'].apply(map_choice)
    
    iti_events_by_type_across_trials = []
    for i in range(num_trials):
        curr_choice = actions[i]
        iti_events = iti_events_across_trials[i]["iti_events"]

        num_stay_licks = (iti_events['Choice'] == curr_choice).sum()
        num_stay_licks_random = ((iti_events['Choice'] == curr_choice) & (iti_events['Choice'] == 1)).sum()
        num_stay_licks_high = ((iti_events['Choice'] == curr_choice) & (iti_events['Choice'] == high_arm[i])).sum()
        num_stay_licks_low = num_stay_licks - num_stay_licks_random - num_stay_licks_high

        num_sample_licks = (iti_events['Choice'] != curr_choice).sum()
        num_sample_licks_random = ((iti_events['Choice'] != curr_choice) & (iti_events['Choice'] == 1)).sum()
        num_sample_licks_high = ((iti_events['Choice'] != curr_choice) & (iti_events['Choice'] == high_arm[i])).sum()
        num_sample_licks_low = num_sample_licks - num_sample_licks_random - num_sample_licks_high

        iti_events_by_type = {
            "num_stay_licks": num_stay_licks,
            "num_stay_licks_random": num_stay_licks_random,
            "num_stay_licks_high": num_stay_licks_high,
            "num_stay_licks_low": num_stay_licks_low,
            "num_sample_licks": num_sample_licks,
            "num_sample_licks_random": num_sample_licks_random,
            "num_sample_licks_high": num_sample_licks_high,
            "num_sample_licks_low": num_sample_licks_low
        }
        iti_events_by_type_across_trials.append(iti_events_by_type)
    return iti_events_by_type_across_trials

def getTypeofITIEventByTrialType(session):
    num_trials = getNumTrials(session)
    choice_mapping = session["choice mapping"]
    actions, rewards = getActionsandRewards(session)
    state, high_arm = getCurrentState(session)

    def map_choice(event):
        choice = event.split('_')[0]
        return choice_mapping.get(choice, -1)

    iti_events_across_trials = getITIEventsAcrossTrials(session)
    for iti_events in iti_events_across_trials:
        iti_events['iti_events']['Choice'] = iti_events['iti_events']['Event'].apply(map_choice)
    
    iti_events_state_0 = {
        "random": [],
        "high": [],
        "low": []
    }
    iti_events_state_1 = {
        "random": [],
        "high": [],
        "low": []
    }
    for i in range(num_trials):
        curr_choice = actions[i]
        curr_state = state[i]
        iti_events = iti_events_across_trials[i]["iti_events"]

        num_stay_licks = (iti_events['Choice'] == curr_choice).sum()
        num_stay_licks_random = ((iti_events['Choice'] == curr_choice) & (iti_events['Choice'] == 1)).sum()
        num_stay_licks_high = ((iti_events['Choice'] == curr_choice) & (iti_events['Choice'] == high_arm[i])).sum()
        num_stay_licks_low = num_stay_licks - num_stay_licks_random - num_stay_licks_high

        num_sample_licks = (iti_events['Choice'] != curr_choice).sum()
        num_sample_licks_random = ((iti_events['Choice'] != curr_choice) & (iti_events['Choice'] == 1)).sum()
        num_sample_licks_high = ((iti_events['Choice'] != curr_choice) & (iti_events['Choice'] == high_arm[i])).sum()
        num_sample_licks_low = num_sample_licks - num_sample_licks_random - num_sample_licks_high

        iti_events_by_type = {
            "num_stay_licks": num_stay_licks,
            "num_stay_licks_random": num_stay_licks_random,
            "num_stay_licks_high": num_stay_licks_high,
            "num_stay_licks_low": num_stay_licks_low,
            "num_sample_licks": num_sample_licks,
            "num_sample_licks_random": num_sample_licks_random,
            "num_sample_licks_high": num_sample_licks_high,
            "num_sample_licks_low": num_sample_licks_low
        }

        if curr_state == 0:
            if curr_choice == 1:
                iti_events_state_0["random"].append(iti_events_by_type)
            elif curr_choice == high_arm[i]:
                iti_events_state_0["high"].append(iti_events_by_type)
            else:
                iti_events_state_0["low"].append(iti_events_by_type)
        elif curr_state == 1:
            if curr_choice == 1:
                iti_events_state_1["random"].append(iti_events_by_type)
            elif curr_choice == high_arm[i]:
                iti_events_state_1["high"].append(iti_events_by_type)
            else:
                iti_events_state_1["low"].append(iti_events_by_type)

    return iti_events_state_0, iti_events_state_1

def getTypeofITIEventByArm(session):
    num_trials = getNumTrials(session)
    choice_mapping = session["choice mapping"]
    reverse_mapping = {value: key for key, value in choice_mapping.items()}
    actions, rewards = getActionsandRewards(session)
    state, high_arm = getCurrentState(session)

    def map_choice(event):
        choice = event.split('_')[0]
        return choice_mapping.get(choice, -1)

    iti_events_across_trials = getITIEventsAcrossTrials(session)
    for iti_events in iti_events_across_trials:
        iti_events['iti_events']['Choice'] = iti_events['iti_events']['Event'].apply(map_choice)
    
    iti_events_by_type_left = []
    iti_events_by_type_right = []
    iti_events_by_type_center = []
    for i in range(num_trials):
        curr_choice = actions[i]
        arm_choice = reverse_mapping[curr_choice]
        random_arm_name = reverse_mapping[1]
        high_arm_name = reverse_mapping[high_arm[i]]
        iti_events = iti_events_across_trials[i]["iti_events"]

        num_stay_licks = (iti_events['Choice'] == curr_choice).sum()
        num_stay_licks_random = ((iti_events['Choice'] == curr_choice) & (iti_events['Choice'] == 1)).sum()
        num_stay_licks_high = ((iti_events['Choice'] == curr_choice) & (iti_events['Choice'] == high_arm[i])).sum()
        num_stay_licks_low = num_stay_licks - num_stay_licks_random - num_stay_licks_high

        num_sample_licks = (iti_events['Choice'] != curr_choice).sum()
        num_sample_licks_random = ((iti_events['Choice'] != curr_choice) & (iti_events['Choice'] == 1)).sum()
        num_sample_licks_high = ((iti_events['Choice'] != curr_choice) & (iti_events['Choice'] == high_arm[i])).sum()
        num_sample_licks_low = num_sample_licks - num_sample_licks_random - num_sample_licks_high

        if random_arm_name == "center":
            num_stay_licks_center = num_stay_licks_random
            num_sample_licks_center = num_sample_licks_random
            if high_arm_name == "left":
                num_stay_licks_left = num_stay_licks_high
                num_sample_licks_left = num_sample_licks_high
                num_stay_licks_right = num_stay_licks_low
                num_sample_licks_right = num_sample_licks_low
            else:
                num_stay_licks_right = num_stay_licks_high
                num_sample_licks_right = num_sample_licks_high
                num_stay_licks_left = num_stay_licks_low
                num_sample_licks_left = num_sample_licks_low
        elif random_arm_name == "left":
            num_stay_licks_left = num_stay_licks_random
            num_sample_licks_left = num_sample_licks_random
            if high_arm_name == "center":
                num_stay_licks_center = num_stay_licks_high
                num_sample_licks_center = num_sample_licks_high
                num_stay_licks_right = num_stay_licks_low
                num_sample_licks_right = num_sample_licks_low
            else:
                num_stay_licks_right = num_stay_licks_high
                num_sample_licks_right = num_sample_licks_high
                num_stay_licks_center = num_stay_licks_low
                num_sample_licks_center = num_sample_licks_low 
        elif random_arm_name == "right":
            num_stay_licks_right = num_stay_licks_random
            num_sample_licks_right = num_sample_licks_random
            if high_arm_name == "center":
                num_stay_licks_center = num_stay_licks_high
                num_sample_licks_center = num_sample_licks_high
                num_stay_licks_left = num_stay_licks_low
                num_sample_licks_left = num_sample_licks_low
            else:
                num_stay_licks_left = num_stay_licks_high
                num_sample_licks_left = num_sample_licks_high
                num_stay_licks_center = num_stay_licks_low
                num_sample_licks_center = num_sample_licks_low 

        iti_events_by_type = {
            "num_stay_licks": num_stay_licks,
            "num_stay_licks_left": num_stay_licks_left,
            "num_stay_licks_center": num_stay_licks_center,
            "num_stay_licks_right": num_stay_licks_right,
            "num_sample_licks": num_sample_licks,
            "num_sample_licks_left": num_sample_licks_left,
            "num_sample_licks_center": num_sample_licks_center,
            "num_sample_licks_right": num_sample_licks_right
        }

        if arm_choice == "left":
            iti_events_by_type_left.append(iti_events_by_type)
        elif arm_choice == "center":
            iti_events_by_type_center.append(iti_events_by_type)
        elif arm_choice == "right":
            iti_events_by_type_right.append(iti_events_by_type)
    return iti_events_by_type_left, iti_events_by_type_center, iti_events_by_type_right

def getStableActionBlocks(session, threshold=5):
    actions, rewards = getActionsandRewards(session)
    state, high_arm = getCurrentState(session)

    last_seen_action = actions[0]
    count = 1
    start = 0
    blocks = []
    block_consistent_state = []

    for i in range(1, len(actions)):
        if actions[i] == last_seen_action:
            count += 1
        else:
            if count >= threshold:
                trial_indices = list(range(start, i))
                blocks.append({
                    "choice": last_seen_action,
                    "start": start,
                    "end": i - 1,
                    "trials": trial_indices,
                    "rewards": rewards[trial_indices],
                    "state": state[trial_indices],
                    "high arm": high_arm[trial_indices],
                    "block length": count
                })
            last_seen_action = actions[i]
            count = 1
            start = i

    # Check the last sequence after the loop
    if count >= threshold:
        trial_indices = list(range(start, len(actions)))
        blocks.append({
            "choice": last_seen_action,
            "start": start,
            "end": len(actions) - 1,
            "trials": trial_indices,
            "rewards": rewards[trial_indices],
            "state": state[trial_indices],
            "high arm": high_arm[trial_indices],
            "block length": count
        })

    return blocks

def getStableActionandStateBlocks(session, threshold=5):
    actions, rewards = getActionsandRewards(session)
    state, high_arm = getCurrentState(session)

    last_seen_action = actions[0]
    last_seen_state = state[0]
    count = 1
    start = 0
    blocks = []

    for i in range(1, len(actions)):
        if actions[i] == last_seen_action and state[i] == last_seen_state:
            count += 1
        else:
            if count >= threshold:
                trial_indices = list(range(start, i))
                blocks.append({
                    "choice": last_seen_action,
                    "start": start,
                    "end": i - 1,
                    "trials": trial_indices,
                    "rewards": rewards[trial_indices],
                    "state": last_seen_state,
                    "high arm": high_arm[start],
                    "block length": count
                })
            last_seen_action = actions[i]
            last_seen_state = state[i]
            count = 1
            start = i

    # Check the last sequence after the loop
    if count >= threshold:
        trial_indices = list(range(start, len(actions)))
        blocks.append({
            "choice": last_seen_action,
            "start": start,
            "end": len(actions) - 1,
            "trials": trial_indices,
            "rewards": rewards[trial_indices],
            "state": last_seen_state,
            "high arm": high_arm[start],
            "block length": count
        })

    return blocks

"""
BEHAVIORAL ANALYSIS
"""
    
def getProportionHighArm(session):
    state_data, high_arm_data = getCurrentState(session)
    actions, rewards = getActionsandRewards(session)
    high_arm_actions = (high_arm_data == actions)
    return high_arm_actions

def getNewHighArmSwitchTrial(session):
    trial_groups = GroupTrialsbyState(session)
    actions, rewards = getActionsandRewards(session)
    switch_trials = []
    num_no_switches = 0
    for i in range(1, len(trial_groups)):
        prev_high_arm = trial_groups[i-1]["high_arm"]
        curr_high_arm = trial_groups[i]["high_arm"]
        new_state_actions = actions[trial_groups[i]["indices"]]
        try:
            new_high_arm_switch = np.where(new_state_actions==curr_high_arm)[0][0] + 1
            switch_trials.append(new_high_arm_switch)
        except:
            num_no_switches = num_no_switches + 1
    return switch_trials, num_no_switches

def getAnyArmSwitchTrial(session):
    trial_groups = GroupTrialsbyState(session)
    actions, rewards = getActionsandRewards(session)
    switch_trials = []
    num_no_switches = 0
    for i in range(1, len(trial_groups)):
        prev_high_arm = trial_groups[i-1]["high_arm"]
        curr_high_arm = trial_groups[i]["high_arm"]
        new_state_actions = actions[trial_groups[i]["indices"]]
        try:
            new_high_arm_switch = np.where(new_state_actions!=prev_high_arm)[0][0] + 1
            switch_trials.append(new_high_arm_switch)
        except:
            num_no_switches = num_no_switches + 1
    return switch_trials, num_no_switches

def ProportionExplorationAfterStateChange(session):
    blocks = getStableActionandStateBlocks(session)
    actions, rewards = getActionsandRewards(session)
    states, high_arms = getCurrentState(session)
    stopped_by_state_change = []

    for i in range(len(blocks)):
        if i != len(blocks) - 1:
            block = blocks[i]
            stopped_trial = block["end"] + 1
            # Checks that the mouse was previously exploiting the high arm up until the state change
            if (block["choice"] == block["high arm"]) and (block["state"] != states[stopped_trial]):
                for j in range(i + 1, len(blocks)):
                    next_block = blocks[j]
                    # Checks that the next block has both the mouse exploiting the new high arm and that the state is still different from the previous block
                    if (next_block["choice"] == next_block["high arm"]) and (next_block["state"] != block["state"]):
                        break 
                states_in_between = states[stopped_trial:next_block["start"] + 1]
                # Checks to make sure there were no state changes between the two identified blocks
                if len(set(states_in_between)) == 1:
                    block_info = {
                        "current block": block,
                        "next block": next_block
                    }
                    stopped_by_state_change.append(block_info)
    
    all_exploratory_actions = []
    for i in range(len(stopped_by_state_change)):
        block_info = stopped_by_state_change[i]
        choice_mapping = session["choice mapping"]
        reverse_mapping = {value: key for key, value in choice_mapping.items()}
        
        trials_in_between = np.arange(block_info["current block"]["end"] + 1, block_info["next block"]["start"])
        exploratory_actions = actions[trials_in_between]
        random_arm_name = reverse_mapping[1]
        high_arm_name = reverse_mapping[block_info["next block"]["high arm"]]

        num_random_choices = 0
        num_high_choices = 0
        num_low_choices = 0
        for action in exploratory_actions:
            arm_choice = reverse_mapping[action]
            if arm_choice == random_arm_name:
                num_random_choices = num_random_choices + 1
            elif arm_choice == high_arm_name:
                num_high_choices = num_high_choices + 1
            else:
                num_low_choices = num_low_choices + 1
        
        all_exploratory_actions.append({
            "random": num_random_choices,
            "high": num_high_choices,
            "low": num_low_choices
        })
    
    return all_exploratory_actions

def ProportionExplorationWithinState(session):
    blocks = getStableActionandStateBlocks(session)
    num_trials = getNumTrials(session)
    actions, rewards = getActionsandRewards(session)
    states, high_arms = getCurrentState(session)
    state_change_indices = np.where(np.diff(states) != 0)[0] + 1
    
    all_exploratory_actions = []

    for i in range(len(blocks)):
        block = blocks[i]
        stopped_trial = block["end"] + 1

        # Ignore the last block, if it goes until the end of the session
        if stopped_trial == num_trials:
            continue

        # If it's the last block, then look to see if there's a state change or if there are relevant trials before the end of the session
        if i == len(blocks) - 1:
            
            # Check if the animal was exploiting the high arm and that the block didn't end because of a state change
            if (block["choice"] == block["high arm"]) and (block["state"] == states[stopped_trial]) and (stopped_trial != num_trials):

                next_state_change = next((index for index in state_change_indices if index > block["end"]), None)

                # Check if there's a state change or if the session ended
                if next_state_change is None:
                    exploratory_actions = actions[stopped_trial:]
                else:
                    exploratory_actions = actions[stopped_trial:next_state_change]

                choice_mapping = session["choice mapping"]
                reverse_mapping = {value: key for key, value in choice_mapping.items()}
                random_arm_name = reverse_mapping[1]
                high_arm_name = reverse_mapping[block["high arm"]]

                num_random_choices = 0
                num_high_choices = 0
                num_low_choices = 0
                for action in exploratory_actions:
                    arm_choice = reverse_mapping[action]
                    if arm_choice == random_arm_name:
                        num_random_choices = num_random_choices + 1
                    elif arm_choice == high_arm_name:
                        num_high_choices = num_high_choices + 1
                    else:
                        num_low_choices = num_low_choices + 1
                
                all_exploratory_actions.append({
                    "random": num_random_choices,
                    "high": num_high_choices,
                    "low": num_low_choices
                })

        else:

            # Checks that the mouse was previously exploiting the high arm and that the state didn't change once it stopped
            if (block["choice"] == block["high arm"]) and (block["state"] == states[stopped_trial]):
                
                next_state_change = next((index for index in state_change_indices if index > block["end"]), None)
                next_block_start = blocks[i + 1]["start"]

                if next_state_change is None:
                    exploratory_actions = actions[stopped_trial:]
                elif next_state_change < next_block_start:
                    exploratory_actions = actions[stopped_trial:next_state_change]
                else:
                    exploratory_actions = actions[stopped_trial:next_block_start]
                
                choice_mapping = session["choice mapping"]
                reverse_mapping = {value: key for key, value in choice_mapping.items()}
                random_arm_name = reverse_mapping[1]
                high_arm_name = reverse_mapping[block["high arm"]]

                num_random_choices = 0
                num_high_choices = 0
                num_low_choices = 0
                for action in exploratory_actions:
                    arm_choice = reverse_mapping[action]
                    if arm_choice == random_arm_name:
                        num_random_choices = num_random_choices + 1
                    elif arm_choice == high_arm_name:
                        num_high_choices = num_high_choices + 1
                    else:
                        num_low_choices = num_low_choices + 1
                
                all_exploratory_actions.append({
                    "random": num_random_choices,
                    "high": num_high_choices,
                    "low": num_low_choices
                })
    
    return all_exploratory_actions

def ProportionofTrialsOnceStabilized(session, threshold=5):
    blocks = getStableActionandStateBlocks(session)
    num_trials = getNumTrials(session)

    actions, rewards = getActionsandRewards(session)
    states, high_arms = getCurrentState(session)
    trial_groups = GroupTrialsbyState(session)

    first_blocks = []

    for trial_group in trial_groups:
        state_start = trial_group["indices"][0]
        state_end = trial_group["indices"][-1]
        for block in blocks:
            if block["start"] >= state_start and block["start"] < state_end and block["choice"] == trial_group["high_arm"]:
                first_blocks.append({
                    "block": block,
                    "state end": state_end
                })
                break
    
    choice_mapping = session["choice mapping"]
    reverse_mapping = {value: key for key, value in choice_mapping.items()}
    random_arm_name = reverse_mapping[1]
    num_random_choices = 0
    num_high_choices = 0
    num_low_choices = 0
    for first_block in first_blocks:

        block = first_block["block"]
        start = block["start"] + threshold
        end = first_block["state end"] + 1
        high_arm_name = reverse_mapping[block["high arm"]]
        curr_actions = actions[start:end]

        for action in curr_actions:
            arm_choice = reverse_mapping[action]
            if arm_choice == random_arm_name:
                num_random_choices = num_random_choices + 1
            elif arm_choice == high_arm_name:
                num_high_choices = num_high_choices + 1
            else:
                num_low_choices = num_low_choices + 1
    
    session_choices = {
        "random": num_random_choices,
        "high": num_high_choices,
        "low": num_low_choices
    }

    return session_choices

def getProportionEachArmOverTime(session, window=5):
    actions, rewards = getActionsandRewards(session)
    states, high_arms = getCurrentState(session)
    back = window - 1

    choice_mapping = session["choice mapping"]
    reverse_mapping = {value: key for key, value in choice_mapping.items()}
    
    prob_0 = []
    prob_1 = []
    prob_2 = []
    prob_high = []
    prob_low = []
    
    for i in range(len(actions)):
        if i >= back:
            last_5_trials = actions[i-back:i+1]
            prob_0.append(np.mean(last_5_trials == 0))
            prob_1.append(np.mean(last_5_trials == 1))
            prob_2.append(np.mean(last_5_trials == 2))

            last_5_high_arms = high_arms[i-back:i+1]
            num_high_arm_choices = np.sum(last_5_trials == last_5_high_arms)
            prob_high.append(num_high_arm_choices / window)

            curr_prob_high = num_high_arm_choices / window
            curr_prob_random = np.mean(last_5_trials == 1)
            curr_prob_low = 1 - curr_prob_high - curr_prob_random
            prob_low.append(curr_prob_low)
    
    if reverse_mapping[1] == "center":
        prob_left = prob_0
        prob_center = prob_1
        prob_random = prob_1
        prob_right = prob_2
    elif reverse_mapping[1] == "left":
        prob_left = prob_1
        prob_random = prob_1
        prob_center = prob_0
        prob_right = prob_2
    elif reverse_mapping[1] == "right":
        prob_left = prob_0
        prob_center = prob_2
        prob_right = prob_1
        prob_random = prob_1
    
    return prob_0, prob_1, prob_2, prob_left, prob_center, prob_right, prob_high, prob_low, prob_random